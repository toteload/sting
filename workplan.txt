sting 0.2
-------------------------------------------------------------------------------
Add pathtracing basics to make things pretty kindof :)

stuff with normals: 
[ ] Set default winding order to the triangles to determine normal direction
    and barycentric coordinates orientation. Make this consistent in the code.
    [ ] normal_lerp, RenderTriangle constructor, maybe more
[ ] calculate interpolated normals from triangle soup
[ ] normal packing

[ ] next event estimation
    [x] need a list of all the lights

    [ ] also take the skydome into consideration as a direct light, this could
        be a bit tricky but it is possible. read it in an article :)

[x] cosine weighted path tracing
[x] basic materials:
    [x] diffuse
    [x] emissive
    [x] mirror
[x] environment map
[x] add normals to triangle mesh
[x] pathtracing!, limit the depth.
[x] accumulator
[x] rng for gpu
[x] looking around with mouse

sting 0.2.1
-------------------------------------------------------------------------------
[ ] give the different rendering functions better names in fillimage.cu
[ ] rename fillimage.cu :|
[ ] verify the output range of random_u32_max
[ ] ray struct now also contains t_min and t_max, change intersecting
    functions to actually use these if necessary, intersect codes don't need
    to use them

Stuff to change about the code
-------------------------------------------------------------------------------
Currently using a `surface` in the CUDA code to write to the screen via a
cudaArray, but this is not really necessary and you can just get a device
pointer instead of a cudaArray which you should be able to also write to. I
found online that cudaArrays are mapped in memory like texures, so optimized
for 2D local access with a curve or something like that. However, this is
completely unnecessary since we just run the code over the entire buffer and
don't need 2D local access, so storing it like 2D access doesn't provide any
benefit on that front. And removing the surface would make the code a little
bit cleaner :) maybe faster. Probably not, but also not slower probably. Would
have to try.


sting 0.3
-------------------------------------------------------------------------------
Adding the wavefront architecture!

sting 0.4
-------------------------------------------------------------------------------
The BVH optimization update!

[ ] top level BVH
[ ] MBVH instead of BVH












Just stuff I may want to add or change but not yet planned in
-------------------------------------------------------------------------------
[ ] normal packing and unpacking
[ ] nested instancing
[ ] debug statistics: framerate, ms per frame, maybe frame time histogram
[ ] add functionality to have the render buffer size and the screen size
    to be different dimensions
[ ] optimize AABB with SIMD
[ ] improve the camera with fov instead of plane distance, is a bit more
    natural to setup like that
[ ] more materials!
[ ] DOF camera
[ ] variance reduction techniques: russian roulette, next event estimation
[ ] add Disney BRDF (looks pretty?)
[ ] random number generation on the GPU or some sort of pseudo random sampling
    BLUE NOISE!

sting 0.1
-------------------------------------------------------------------------------
This version is meant to have a raytracer that can actually render something
at reasonably interactive frame rate.
It will add BVH acceleration structure and loading of triangle
meshes, with intersection of the BVH on the GPU.

[x] bvh building and intersection
[x] loading triangle meshes
[x] uploading triangle mesh bvh to gpu and intersection on the gpu

[x] cleanup everything once the features for this version have been
    implemented

sting 0.1.1
-------------------------------------------------------------------------------
[x] fix the camera


DONE
-------------------------------------------------------------------------------
[x] add triangle intersection
[x] point lights, with shadow casts and simple lambertian shading
[x] point camera
[x] a buffer for the raytracer to write results to, then every frame
    this buffer gets read from and written to the screen, basically an
    accumulator
[x] rays with sphere intersection, without camera just shoot straight
    ahead
[x] add interactive camera controls
[x] create a window without opengl
[x] add opengl context
[x] setup rendering code for drawing a texture across the whole screen
[x] add cuda test code that writes to a texture
[x] setup cuda opengl interop
